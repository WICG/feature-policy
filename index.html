<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Linux version 5.3.15">
  <title>Feature Policy</title>
  <meta charset='utf-8'>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class=
  'remove'>
  </script>
  <script class='remove'>
  var respecConfig = {
    shortName: "feature-policy",
    specStatus: "CG-DRAFT",
    useExperimentalStyles: true,
    edDraftURI: "http://wicg.github.io/feature-policy/",
    editors: [{
      name: "Ilya Grigorik",
      url: "https://www.igvita.com/",
      mailto: "igrigorik@gmail.com",
      company: "Google",
      companyURL: "https://google.com/",
      w3cid: "56102"
    }, {
      name: "Mike West",
      mailto: "mkwst@google.com",
      company: "Google",
      companyURL: "https://google.com/",
      w3cid: "56384"
    }],
    wg: "WICG",
    subjectPrefix: "[feature-policy]",
    // noLegacyStyle: true,
    otherLinks: [{
      key: 'Repository',
      data: [{
        value: 'We are on Github.',
        href: 'https://github.com/wicg/feature-policy/'
      }, {
        value: 'File a bug.',
        href: 'https://github.com/wicg/feature-policy/issues'
      }, {
        value: 'Commit history.',
        href: 'https://github.com/wicg/feature-policy/commits/gh-pages/index.html'
      }]
    }],
    localBiblio:  {
      'PERMISSION-DELEGATION': {
        title: 'Permission Delegation To Embedded Web Applications',
        href: 'https://noncombatant.github.io/permission-delegation-api/',
        authors: [
          'Raymes Khoury',
          'Chris Palmer'
        ],
        date: 'March 30 2016'
      },
      'HTTP-JFV': {
        title: 'A JSON Encoding for HTTP Header Field Values',
        href: 'https://greenbytes.de/tech/webdav/draft-ietf-httpbis-jfv-02.html',
        authors: [
          'Julian Reschke'
        ],
        date: 'October 24 2016'
      }
    }
  };
  </script>
  <style>
    table {
      border-collapse: collapse;
      border-style: hidden hidden none hidden;
    }
    table td, table th {
      border-left: solid;
      border-right: solid;
      border-bottom: solid thin;
      vertical-align: top;
      padding: 0.2em;
    }
    th {
      background-color: #ccc;
    }
  </style>
</head>
<body>
  <section id='abstract'>
    <p>This specification defines a mechanism that allows developers to
    selectively enable and disable use of various browser features and
    APIs.</p>
  </section>
  <section id='sotd'>
    <p>This is a <strong>work in progress</strong> and may change without any
    notices.</p>
  </section>
  <section>
    <h2>Introduction</h2>
    <p>The web-platform provides an ever-expanding set of features and APIs,
    offering richer functionality, better developer ergonomics, and improved
    performance. However, a missing piece is the ability for the developer to
    selectively enable, disable, or modify the behavior of some of these
    browser features and APIs within their application:</p>
    <ol>
      <li>The developer may want to selectively _disable_ access to certain
      browser features and APIs to "lock down" their application, as a security
      or performance precaution, to prevent own and third-party content
      executing within their application from introducing unwanted or
      unexpected behaviors within their application.</li>
      <li>The developer may want to selectively _enable_ access to certain
      browser features and APIs which may be disabled by default - e.g. some
      features may be disabled by default in embedded context unless explicitly
      enabled; some features may be subject to other policy requirements.</li>
      <li>The developer may want to use the policy to assert a promise to a
      client or an embedder about the use—or lack of thereof—of certain
      features and APIs. For example, to enable certain types of "fast path"
      optimizations in the browser, or to assert a promise about conformance
      with some requirements set by other embedders - e.g. various social
      networks, search engines, and so on.</li>
    </ol>
    <p>This specification defines a feature policy mechanism that addresses the
    above use cases.</p>
    <section>
      <h2>Examples</h2>
      <div class="example">
        <p>SecureCorp Inc. wants to disable use of Vibration and Geolocation
        APIs within their application. It can do so by delivering the following
        HTTP response header to define a feature policy:</p>
        <pre>
        <a>Feature-Policy</a>: {"<a>vibrate</a>": [], "<a>geolocation</a>": []}</pre>
        <p>By specifying an empty list of origins, the specified features will
        be disabled for all browsing contexts, regardless of their origin.</p>
      </div>
      <div class="example">
        <p>SecureCorp Inc. wants to disable use of Geolocation API within all
        browsing contexts except for its own origin and those whose origin is
        "<code>https://example.com</code>". It can do so by delivering the
        following HTTP response header to define a feature policy:</p>
        <pre>
        <a>Feature-Policy</a>: {"<a>geolocation</a>": ["self", "https://example.com"]}</pre>
        <p>The <a>whitelist</a> is a list of one or more origins, which can
        include the application's origin, optionally with the keyword
        "<code>self</code>", and any third-party origin.</p>
      </div>
      <div class="example">
        <p>SecureCorp Inc. is hosting an application on
        "<code>https://example.com</code>" and wants to disable camera and
        microphone input on its own origin but enable it for a whitelisted
        embedee ("<code>https://other.com</code>"). It can do so by delivering
        the following HTTP response header to define a feature policy:</p>
        <pre>
<a>Feature-Policy</a>: {"<a>camera</a>": ["https://other.com"], "<a>microphone</a>": ["https://other.com"]}</pre>
        <p>Some features are disabled by default in embedded contexts. The
        enable policy allows the application to selectively enable such
        features for whitelisted origins.</p>
      </div>
      <div class="example">
        <p>FastCorp Inc. wants to disable geolocation for all browsing
        contexts, except for a specific iframe. It can do so by delivering the
        following HTTP response header to define a feature policy:</p>
        <pre>
<a>Feature-Policy</a>: {"<a>geolocation</a>": ["self"]}</pre>
        <p>and including an "<code>allow</code>" attribute on the iframe
        element:</p>
        <pre>
&lt;iframe src="https://other.com/map" <a href=
"#the-allow-attribute-of-the-iframe-element">allow</a>="<a>geolocation</a>"&gt;&lt;/iframe&gt;</pre>
        <p>Iframe attributes can selectively enable features in certain frames,
        and not in others, even if those contain documents from the same
        origin.</p>
      </div>
    </section>
    <section>
      <h2>Other and related mechanisms</h2>
      <p>[[HTML5]] defines a [[sandbox attribute]] for <code>iframe</code>
      elements that allows developers to reduce the risk of including
      potentially untrusted content by imposing restrictions on content's
      abilities - e.g. prevent it from submitting forms, running scripts and
      plugins, and more. The [sandbox directive] defined by [[CSP2]] extends
      this capability to any resource, framed or not, to ask for the same set
      of restrictions - e.g. via an HTTP response header
      (<code>Content-Security-Policy: sandbox</code>). These mechanisms enable
      the developer to:</p>
      <ul>
        <li>Set and customize a sandbox policy on any resource via CSP.</li>
        <li>Set and customize individual sandbox policies on each
        <code>iframe</code> element within their application.</li>
      </ul>
      <p>However, there are several limitations to the above mechanism: the
      developer cannot automatically apply a policy across all contexts, which
      makes it hard or impossible to enforce consistently in some cases (e.g.
      due to third-party content injecting frames, which the developer does not
      control); there is no mechanism to selectively enable features that may
      be off by default; the sandbox mechanism uses a whitelist approach which
      is impossible to extend without compatibility risk.</p>
      <p>Feature Policy is intended to be used in combination with the sandbox
      mechanism (i.e. it does not duplicate feature controls already covered by
      sandbox), and provides an extensible mechanism that addresses the above
      limitations.</p>
    </section>
  </section>
  <section>
    <h2>Framework</h2>
    <section>
      <h2>Policies</h2>
      <p>A <dfn>feature policy</dfn> may be applied to a [Document] or
      [WorkerGlobalScope] and consists of:</p>
      <ul>
        <li>A set of <a data-lt="inherited policy set">inherited policies</a>.
        </li>
        <li>A <a data-lt="declared policy">declared policy</a>.
        </li>
      </ul>
    </section>
    <section>
      <h2>Inherited policies</h2>
      <p>Each document in a frame tree inherits a set of policies from its
      parent frame, or in the case of the top-level document, from the defined
      defaults for each feature. This inherited policy set determines the
      initial state (enabled or disabled) of each feature, and whether it can
      be controlled by a <a>declared policy</a> in the document.</p>
      <p>In a top-level document, or a [WorkerGlobalScope], the inherited
      feature set is based on defined defaults for each feature.</p>
      <p>In a document in an [nested browsing context], the inherited feature
      set is based on the parent document's feature policy, as well as any
      allow attributes defined on the browsing context container.</p>
      <p>An <dfn data-lt="inherited policy|inherited policies">inherited
      policy</dfn> for a <a>feature</a> is a boolean associated with that
      feature in a Document or WorkerGlobalScope. It can take the value Enabled
      or Disabled.</p>
      <p>An <dfn>inherited policy set</dfn> for a Document or WorkerGlobalScope
      is the set of <a>inherited policies</a> for each <a>feature</a> available
      in that scope.</p>
    </section>
    <section>
      <h2>Declared policies</h2>
      <p>A <dfn data-lt="declared policy|declared feature policy">declared
      policy</dfn> is a set of <a>policy directives</a>, which may be the empty
      set.</p>
      <p>The <a>declared policy</a> is represented in HTTP headers and HTML
      attributes as a JSON string.</p>
      <p>A document is considered <dfn>feature-policy-aware</dfn> if it has a
      <a>declared policy</a> delivered via a Feature-Policy HTTP header.</p>
      <p>A document is which is not <a>feature-policy-aware</a> is considered
      <dfn>feature-policy-oblivious</dfn>.</p>
    </section>
    <section>
      <h2>Header policies</h2>
      <p>A <dfn>header policy</dfn> is a declared policy delivered via an HTTP
      header with the document, or in an HTML meta element in the document's
      HEAD. These form the document's <a>feature policy</a>'s <a>declared
      policy</a>.</p>
    </section>
    <section>
      <h2>Container policies</h2>
      <p>In addition to the <a>header policy</a>, each frame has a
      <dfn>container policy</dfn>, which is a <a>policy directive</a>, which
      may be empty. The <a>container policy</a> can set by attributes on the
      browsing context container.</p>
      <p>The <a>container policy</a> for a frame influences the <a>inherited
      policy</a> of any document loaded into that frame. (See <a href=
      "#define-inherited-policy"></a>)</p>
      <div class="note">
        Currently, the <a>container policy</a> cannot be set directly, but is
        indirectly set by <code>iframe</code> "<a href=
        "#allowfullscreen"><code>allowfullscreen</code></a>", "<a href=
        "#allowpaymentrequest"><code>allowpaymentrequest</code></a>", and
        "<a href=
        "#the-allow-attribute-of-the-iframe-element"><code>allow</code></a>"
        attributes. Future revisions to this spec may introduce a mechanism to
        explicitly declare the full <a>container policy</a>.
      </div>
    </section>
    <section>
      <h2>Policy directives</h2>
      <p>A <dfn data-lt="policy directive|policy directives">policy
      directive</dfn> is a dictionary, mapping <a>feature names</a> to
      corresponding <a>whitelists</a> of origins.</p>
      <p>The following sections define the set of known <a>feature names</a>.
      Future versions of this document may define additional such names and
      user agents MUST ignore policy directives with unrecognized names when
      parsing the policy.</p>
    </section>
    <section>
      <h2>Whitelists</h2>
      <p>A feature policy <dfn data-lt="whitelist|whitelists">whitelist</dfn>
      is a set of origins. A <a>whitelist</a> may be <em>empty</em>, in which
      case it does not match any origin, or it may contain a list of origins,
      or it may match every origin. When defining a whitelist in a policy, the
      special origin "self" may be used, which refers to the origin of document
      which the policy is associated with.</p>
      <p>A <a>whitelist</a> <dfn>matches</dfn> an origin <var>o</var> if it
      matches every origin, or if it contains an origin which is [same
      origin-domain] with <var>o</var>.</p>
    </section>
    <section>
      <h2>Default Whitelists</h2>
      <p>Every feature controlled by policy has a <dfn data-lt=
      "default whitelist|default whitelists">default whitelist</dfn>, which is
      a <a>whitelist</a>. The <a>default whitelist</a> controls the origins
      which are allowed to access the feature when used in a top-level document
      with no declared policy, and also determines whether access to a feature
      is automatically delegated to child documents.</p>
      <p>Features are currently defined to have one of these three <a>default
      whitelists</a>:</p>
      <dl>
        <dt>["<code>*</code>"]</dt>
        <dd>The feature is allowed at the top level by default, and when
        allowed, is allowed by default to documents in child frames.</dd>
        <dt>["<code>self</code>"]</dt>
        <dd>The feature is allowed at the top level by default, and when
        allowed, is allowed by default to same-origin domain documents in child
        frames, but is disallowed by default in cross-origin documents in child
        frames.</dd>
        <dt>[]</dt>
        <dd>The feature is disallowed at the top level by default, and is also
        disallowed by default to documents in child frames.</dd>
      </dl>
    </section>
  </section>
  <section>
    <h2>Feature Policy Serialization</h2>
    <section>
      <h2><dfn>JSON serialization</dfn></h2>
      <p>Declared Policies are represented in HTTP headers and in HTML
      attributes as JSON strings.</p>
      <p>The following ABNF rules define the structure of the feature policy
      JSON serialization. It makes use of definitions found in [[!JSON]]</p>
      <pre class="bnf">
      declared-policy = begin-array directive *(value-separator directive) end-array
      directive = begin-object feature-declaration *(value-separator feature-declaration) end-object
      feature-declaration = quotation-mark feature-name quotation-mark name-separator whitelist
      feature-name = string
      whitelist = begin-array quoted-origin-value *(value-separator quoted-origin-value) end-array
      quoted-origin-value = quotation-mark origin-value quotation-mark
      origin-value = "*" / "self" / origin</pre>
      <div class="note">
        The string "<code>self</code>" may be used as an origin in a whitelist.
        When it is used in this way, it will refer to the origin of the
        document which contains the feature policy.
      </div>
      <div class="note">
        The begin-array and end-array marks ("[" and "]") are semantically part
        of the JSON representation of the declared policy, but they do not
        appear in the HTTP headers or meta elements. Those characters are added
        to the HTTP headers before parsing, so that the entire set of
        concatenated headers are parsed as a single array.
      </div>
    </section>
  </section>
  <section>
    <h2>Delivery</h2>
    <section>
      <h2>Feature-Policy HTTP Header Field</h2>
      <p>The <dfn>Feature-Policy</dfn> HTTP header field can be used in the
      [response] (server to client) to communicate the <a>feature policy</a>
      that should be enforced by the client.</p>
      <p>The header's value is the <a>JSON serialization</a> of the elements of
      the <a>declared policy</a>:</p>
      <div class="issue">
        Define this without reference to the abandoned JFV proposal. Consider
        changing the "array of dictionaries" semantics required by JFV to a
        single dictionary, for simplicity.
      </div>
      <pre class="abnf">
        FeaturePolicy = 1#json-field-value
                  ; See Section 2 of [[HTTP-JFV]], and Section 2 of [[RFC7159]]
      </pre>
      <p>When the user agent receives a <code>Feature-Policy</code> header
      field, it MUST <a href="#process-response-policy">process</a> and
      <a>enforce</a> the serialized policy as described in <a href=
      "#integration-with-html"></a>.</p>
    </section>
    <section>
      <h2>The <code>meta</code> element</h2>
      <p>A [Document] may deliver a policy via one or more HTML [meta] elements
      whose [http-equiv] attributes are an [ASCII case-insensitive] match for
      the string "<code>Feature-Policy</code>". For example:</p>
      <pre class="example nolinks">
    &lt;meta http-equiv="Feature-Policy"
content='{"webrtc": [], "geolocation": ["https://example.com"]}'&gt;
      </pre>
      <p>The <code>meta</code> policy is processed as defined in <a href=
      "#process-meta-policy"></a> and modifications to the
      [content][meta-content] attribute of a <code>meta</code> element after
      the element has been parsed MUST be ignored.</p>
      <p>To ensure that the policy can be applied before any scripts are able
      to execute within the [Document]'s [browsing context], the following
      restrictions apply to <code>meta</code> policy:</p>
      <ul>
        <li>The elements containing the <code>meta</code> policy MUST be
        serialized completely within the first 1024 bytes of the document.</li>
        <li>The elements containing the <code>meta</code> policy MUST appear
        before any [script] or [link] elements.</li>
      </ul>
      <div class="note">
        Since JSON serialization requires U+0022 QUOTATION MARK as a string
        delimiter, it is recommended that the [content][meta-content] attribute
        of the Feature Policy [meta] tag be delimited with U+0027 APOSTROPHE,
        to avoid having to encode JSON delimeters as "<code>&amp;quot;</code>"
      </div>
      <div class="issue">
        TODO: Ensure that inserting this element after scripts can run has no
        effect.
      </div>
    </section>
    <section>
      <h2>The <code>allow</code> attribute of the <code>iframe</code>
      element</h2>
      <pre class="idl">
partial interface HTMLIFrameElement {
    [CEReactions, SameObject, PutForwards=value] readonly attribute DOMTokenList allow;
};</pre>
      <p>Iframe elements have an "<code>allow</code>" attribute, which contains
      an unordered set of unique space-separated tokens that are ASCII
      case-insensitive. The allowed values are names of features. Unrecognized
      values must be ignored.</p>
      <p>When not empty, the "<code>allow</code>" attribute will result in
      adding a <a>whitelist</a> for each recognized feature to the frame's
      <a>container policy</a>, when it is contructed.</p>
      <p>The <a>whitelist</a> will contain a single origin, which is the origin
      of URL in the iframe's <code>src</code> attribute.</p>
    </section>
    <section>
      <h2>Additional attributes to support legacy features</h2>
      <p>Some features controlled by Feature Policy have existing iframe
      attributes defined. This specification redefines these attributes to act
      as declared policies for the iframe element.</p>
      <section>
        <h3>allowfullscreen</h3>
        <p>The "<code>allowfullscreen</code>" iframe attribute controls access
        to [Fullscreen interface].</p>
        <p>If the iframe element has an "<code>allow</code>" attribute whose
        value contains the token "<code>fullscreen</code>", then the
        "<code>allowfullscreen</code> attribute should have no effect.</p>
        <p>Otherwise, the presence of an "allowfullscreen" attribute on an
        iframe will result in adding a <a>whitelist</a> of ["<code>*</code>"]
        for the "fullscreen" feature to the frame's <a>container policy</a>,
        when it is constructed.</p>
        <div class="note">
          This is different from the behaviour of <code>&lt;iframe
          allow="fullscreen"&gt;</code>, and is for compatibility with existing
          uses of <code>allowfullscreen</code>. If
          <code>allow="fullscreen"</code> and <code>allowfullscreen</code> are
          both present on an iframe element, then the more restrictive
          whitelist of <code>allow="fullscreen"</code> will be used.
        </div>
      </section>
      <section>
        <h3>allowpaymentrequest</h3>
        <p>The "<code>allowpaymentrequest</code>" iframe attribute controls
        access to [Payment interface].</p>
        <p>If the iframe element has an "<code>allow</code>" attribute whose
        value contains the token "<code>payment</code>", then the
        "<code>allowpaymentrequest</code> attribute should have no effect.</p>
        <p>Otherwise, the presence of an "allowpaymentrequest" attribute on an
        iframe will result in adding a <a>whitelist</a> of ["<code>*</code>"]
        for the "payment" feature to the frame's <a>container policy</a>, when
        it is constructed.</p>
        <div class="note">
          This is different from the behaviour of <code>&lt;iframe
          allow="payment"&gt;</code>, and is for compatibility with existing
          uses of <code>allowpaymentrequest</code>. If
          <code>allow="payment"</code> and <code>allowpaymentrequest</code> are
          both present on an iframe element, then the more restrictive
          whitelist of <code>allow="payment"</code> will be used.
        </div>
      </section>
    </section>
  </section>
  <section>
    <h2>Integrations</h2>
    <p>This document defines a set of algorithms which other specifications
    will use in order to implement the restrictions which Feature Policy
    defines. The integrations are outlined here for clarity, but those external
    documents are the normative references which ought to be consulted for
    detailed information.</p>
    <section>
      <h3>Integration with HTML</h3>
      <ol>
        <li>
          <code>Document</code> and <code>WorkerGlobalScope</code> objects have
          a <a>Feature Policy</a>, which is populated via the <a href=
          "#initialize-for-global"></a> algorithm that is called during the
          "Initialising a new <code>Document</code> object" and "Run a Worker"
          algorithms.
        </li>
        <li>Replace the existing step 12 of "Initialising a new
        <code>Document</code> object" with the following step:
          <ul>
            <li>
              <a href="#initialize-for-global">Initialize the feature
              policy</a> for the <code>Document</code>
            </li>
          </ul>
        </li>
        <li>A <a>feature policy</a> is <dfn data-lt="enforce">enforced</dfn>
        for a [global object] by setting it as the [global object]'s <a>Feature
        Policy</a>.
        </li>
        <li>
          <p>The "[prepare a script]" algorithm calls into <a href=
          "#is-feature-enabled"></a> algorithm to determine whether or not to
          execute a script, as follows:</p>
          <ol>
            <li>Add the following step before the current step 10 (which is the
            first of several "disabled" checks):
              <ul>
                <li>If the <code>script</code> element's
                "<code>non-blocking</code>" flag is unset, the
                <code>script</code>'s type is "<code>classic</code>", and the
                <a href="#is-feature-enabled"></a> algorithm returns
                "<code>Disabled</code>" when executed upon the
                <code>script</code> element's node document's global object for
                the feature "<code>sync-script</code>", then abort these steps
                at this point. The script is not executed.
                </li>
              </ul>
            </li>
          </ol>
        </li>
        <li>
          <p>The "[allowed to use]" algorithm calls into <a href=
          "#is-feature-enabled"></a>, as follows:</p>
          <ol>
            <li>Replace the current steps #3 and #4 with the following step:
              <ul>
                <li>If <code>Document</code>'s <a>feature policy</a> enables
                the feature indicated by <code>allowattribute</code> for the
                origin of <code>Document</code>, then return true.
                </li>
              </ul>
            </li>
          </ol>
        </li>
      </ol>
      <div class="issue">
        Monkey-patching! As soon as we know that this is the direction we wish
        to pursue, upstream all of this.
      </div>
      <section>
        <h2>Process meta policy</h2>
        <div class="note">
          This section extends HTML's <code>meta</code> [pragma directives].
        </div><strong>Feature policy state
        (http-equiv="feature-policy")</strong>
        <p>This pragma extends the declared feature policy for a
        [Document].</p>
        <ol>
          <li>If the [meta] element has no [content] attribute, or if that
          attribute's value is the empty string, then abort these steps.</li>
          <li>If the [meta] element is not being inserted in into the
          [Document]'s [head] element, or if is inserted after any [script] or
          [link] elements, then abort these steps.</li>
          <li>Let document be the meta element's node document</li>
          <li>Let <var>value</var> be the result of parsing the value of [meta]
          element's [content] attribute with a [JSON parser].</li>
          <li>If parsing returns an error, or <var>value</var> is not a [JSON
          object], then abort these steps.</li>
          <li>Let <var>directive</var> be the result of running <a href=
          "#parse-policy-directive-from-value-and-origin"></a> on
          <var>value</var> and <var>document</var>'s [origin].
          </li>
          <li>Run <a href="#merge-directive-with-declared-policy"></a> with
          <var>directive</var> and document's feature policy's declared policy
          </li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>Algorithms</h2>
    <section>
      <h2>Process response policy</h2>
      <p>Given a [response] (<var>response</var>) and [global object]
      (<var>global</var>), this algorithm returns a <a>declared feature
      policy</a>.</p>
      <ol>
        <li>Abort these steps if the <var>response</var>’s [header list] does
        not contain a [header] whose [name] is
        "<code>Feature-Policy</code>".</li>
        <li>Let <var>header</var> be the concatenation of the [value]s of all
        [header] fiels in <var>response</var>’s [header list] whose name is
        "<code>Feature-Policy</code>", according to [RFC7230, 3.2.2]</li>
        <li>Add a leading "[" U+005B character, and a trailing "]" U+005D
        character to <var>header</var>.</li>
        <li>Let <var>feature policy</var> be the result of executing <a href=
        "#parse-header-from-value-and-origin"></a> on <var>header</var> and
        <var>global</var>'s origin.
        </li>
        <li>Return <var>feature policy</var>.</li>
      </ol>
    </section>
    <section>
      <h2><dfn>Parse header from <var>value</var> and
      <var>origin</var></dfn></h2>
      <p>Given a string (<var>value</var>) and an [origin] (<var>origin</var>)
      this algorithm will return a <a>declared feature policy</a>.</p>
      <ol>
        <li>Let <var>policy</var> be an empty list.</li>
        <li>Let <var>list</var> be the result of parsing <var>value</var> with
        a [JSON Parser]. If <var>value</var> cannot be parsed, return
        <var>policy</var>.</li>
        <li>Note: If <var>value</var> can be parsed, <var>list</var> must be a
        valid [JSON Array].</li>
        <li>For each <var>element</var> in <var>list</var>:
          <ol>
            <li>If <var>element</var> is not a JSON object, skip these steps
            and continue with the next element.</li>
            <li>Let <var>directive</var> be the result of executing <a href=
            "#parse-policy-directive-from-value-and-origin"></a> on
            <var>element</var> and <var>origin</var>
            </li>
            <li>Run <a href="#merge-directive-with-declared-policy"></a> on
            <var>directive</var> and <var>policy</var>.
            </li>
          </ol>
        </li>
        <li>Return <var>policy</var>.</li>
      </ol>
    </section>
    <section>
      <h2><dfn>Parse policy directive from <var>value</var> and
      <var>origin</var></dfn></h2>
      <p>Given a JSON object (<var>value</var>) and an [origin]
      (<var>origin</var>) this algorithm will return a <a>policy
      directive</a>.</p>
      <ol>
        <li>Let <var>directive</var> be a new dictionary, mapping features to
        <a>whitelist</a>s.
        </li>
        <li>For each <var>key</var> and associated <var>targetlist</var> in
        <var>value</var>:
          <ol>
            <li>If <var>key</var> is not equal to the name of any recognized
            feature, abort these steps and continue with the next
            <var>key</var> and <var>targetlist</var>.</li>
            <li>Let <var>feature</var> be the feature named by
            <var>key</var>.</li>
            <li>If <var>targetlist</var> is not an array, abort these steps and
            continue with the next <var>key</var> and
            <var>targetlist</var>.</li>
            <li>Let <var>whitelist</var> be a new <a>whitelist</a>.
            </li>
            <li>If <var>targetlist</var> contains the string "<code>*</code>",
            set <var>whitelist</var> to match every origin.</li>
            <li>Otherwise, for each <var>element</var> in
            <var>targetlist</var>:
              <ol>
                <li>If <var>element</var> is an ASCII case-insensitive match
                for "<code>self</code>", let result be <var>origin</var>.</li>
                <li>Otherwise, let <var>result</var> be the result of executing
                the URL parser on <var>element</var>.</li>
                <li>If <var>result</var> is not failure:
                  <ol>
                    <li>Let <var>target</var> be the origin of
                    <var>result</var>.</li>
                    <li>If <var>target</var> is not an opaque origin, append
                    <var>target</var> to <var>whitelist</var>.</li>
                  </ol>
                </li>
              </ol>
            </li>
            <li>Insert <var>whitelist</var> into <var>directive</var> as the
            value for the key <var>feature</var>.</li>
          </ol>
        </li>
        <li>Return <var>directive</var></li>
      </ol>
    </section>
    <section>
      <h2>Merge directive with declared policy</h2>
      <p>Given a policy direcive (<var>directive</var>) and a declared policy
      (<var>policy</var>), this algorithm will modify <var>policy</var> to
      account for the new directive.</p>
      <ol>
        <li>For each <var>feature</var> and associated <var>whitelist</var> in
        <var>directive</var>:
          <ol>
            <li>If <var>policy</var> does not contain a whitelist for
            <var>feature</var>, then add <var>whitelist</var> to
            <var>policy</var> as the whitelist for <var>feature</var>.</li>
          </ol>
        </li>
      </ol>
    </section>
    <section>
      <h2><dfn>Process feature policy attributes</dfn></h2>
      <p>Given an element <var>element</var>, this algorithm returns a
      <a>declared feature policy</a>, which may be empty.</p>
      <ol>
        <li>Let <var>policy</var> be a new <a>policy directive</a>.
        </li>
        <li>Let <var>valid-features</var> be the result of running <a href=
        "#parse-allow-attribute">Parse allow attribute</a> on the value of
        <var>element</var>'s <code>allow</code> attribute.
        </li>
        <li>For each <var>feature</var> in <var>valid-features</var>:
          <ol>
            <li>If <var>policy</var> does not contain a whitelist for
            <var>feature</var>:
              <ol>
                <li>Construct a new declaration for <var>feature</var>, whose
                whitelist is <var>origin</var>.</li>
                <li>Add <var>declaration</var> to <var>policy</var>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>If <var>element</var> is an [iframe element]:
          <ol>
            <li>If <var>element</var>'s <code>allowfullscreen</code> attribute
            is specified, and <var>policy</var> does not contain a whitelist
            for <a>fullscreen</a>,
              <ol>
                <li>Construct a new declaration for <a>fullscreen</a>, whose
                whitelist matches all origins.
                </li>
                <li>Add <var>declaration</var> to <var>policy</var>.</li>
              </ol>
            </li>
            <li>If <var>element</var>'s <code>allowpaymentrequest</code>
            attribute is specified, and <var>policy</var> does not contain a
            whitelist for <a>payment</a>,
              <ol>
                <li>Construct a new declaration for <a>payment</a>, whose
                whitelist matches all origins.
                </li>
                <li>Add <var>declaration</var> to <var>policy</var>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Return <var>policy</var>.</li>
      </ol>
    </section>
    <section>
      <h2><dfn>Parse allow attribute</dfn></h2>
      <p>Given a <var>list</var>, this algorithm returns a list of <a>feature
      name keywords</a>, which may be empty.</p>
      <ol>
        <li>Let <var>valid-features</var> be an empty list.</li>
        <li>If <var>list</var> is <var>null</var> or empty, return
        <var>valid-features</var>.</li>
        <li>For each <var>item</var> in <var>list</var>:
          <ol>
            <li>Convert <var>item</var> to ASCII-lowercase.</li>
            <li>If <var>item</var> matches a defined <a>feature name</a> which
            is not present in <var>valid-features</var>,
              <ol>
                <li>Append <var>item</var> to <var>valid-features</var>.</li>
              </ol>
            </li>
          </ol>
        </li>
        <li>Return <var>valid-features</var>.</li>
      </ol>
    </section>
    <section>
      <h4 id="initialize-for-global">Initialize <var>global</var>'s Feature
      Policy from <var>response</var></h4>
      <p>Given a [response] (<var>response</var>) and a global object
      (<var>global</var>), this algorithm populates <var>global</var>'s
      <a>Feature Policy</a></p>
      <ol>
        <li>Let <var>ips</var> set be an empty set</li>
        <li>Let <var>dps</var> set be an empty set.</li>
        <li>For each <var>feature</var> supported,
          <ol>
            <li>Let <var>i</var> be the result of running <a href=
            "#define-inherited-policy"></a> on <var>feature</var> and
            <var>global</var>
            </li>
            <li>Add <var>i</var> to <var>ips</var>.</li>
          </ol>
        </li>
        <li>Let <var>d</var> be the result of executing <a href=
        "#process-response-policy"></a> on <var>response</var> and
        <var>global</var>.
        </li>
        <li>For each <var>directive</var> in <var>d</var>:
          <ol>
            <li>if the inherited policy in <var>ips</var> for
            <var>directive</var>'s feature is true, then add <var>d</var> to
            <var>dps</var></li>
          </ol>
        </li>
        <li>Let <var>policy</var> be a new <a>feature policy</a>, with
        inherited policy set <var>ihs</var> and declared policy set
        <var>dps</var>.
        </li>
        <li>
          <a>Enforce</a> the policy <var>policy</var>.
        </li>
      </ol>
    </section>
    <section>
      <h4 id="define-inherited-policy">Define an inherited policy for
      <var>feature</var></h4>
      <p>Given a string (<var>feature</var>) and a browsing context
      (<var>context</var>), this algorithm returns the <a>inherited policy</a>
      for that feature.</p>
      <ol>
        <li>If <var>context</var> is a [nested browsing context]:
          <ol>
            <li>let <var>parent</var> be <var>context</var>'s parent browsing
            context's active document.</li>
            <li>Let <var>container policy</var> be the result of running
            <a>process feature policy attributes</a> on <var>context</var>'s
            browsing context container.
            </li>
            <li>If <var>feature</var> is a key in <var>container policy</var>:
              <ol>
                <li>If the <a>whitelist</a> for <var>feature</var> in
                <var>container policy</var> <a>matches</a> <var>origin</var>,
                and <var>parent</var>'s <a>inherited policy</a> for
                <var>feature</var> is Enabled, return Enabled.
                </li>
                <li>Otherwise return Disabled.</li>
              </ol>
            </li>
            <li>Otherwise, if feature is allowed by <var>parent</var>’s
            <a>feature policy</a> for <var>origin</var>, return Enabled.
            </li>
            <li>Otherwise, return Disabled.</li>
          </ol>
        </li>
        <li>Otherwise, return Enabled.</li>
      </ol>
    </section>
    <section>
      <h4 id="is-feature-enabled">Is <var>feature</var> enabled in
      <var>global</var> for <var>origin</var>?</h4>
      <p>Given a string (<var>feature</var>) and a global object
      (<var>global</var>), and an [origin] (<var>origin</var>), this algorithm
      returns "<code>Disabled</code>" if <var>feature</var> should be
      considered disabled, and "<code>Enabled</code>" otherwise.</p>
      <ol>
        <li>Let <var>policy</var> be <var>global</var>'s <a>Feature Policy</a>
        </li>
        <li>If <var>feature</var> is not present in <var>policy</var>'s
        <a>inherited policy set</a>, return "<code>Disabled</code>".
        </li>
        <li>If <var>feature</var> is present in <var>policy</var>'s <a>declared
        policy</a>:
          <ol>
            <li>If the <a>whitelist</a> for <var>feature</var> in
            <var>policy</var>'s <a>declared policy</a> <a>matches</a>
            <var>origin</var>, then return "<code>Enabled</code>".
            </li>
            <li>Otherwise return "<code>Disabled</code>".</li>
          </ol>
        </li>
        <li>If <var>feature</var>'s <a>default whitelist</a> is
        <code>["*"]</code>, return "<code>Enabled</code>".
        </li>
        <li>If <var>feature</var>'s <a>default whitelist</a> is
        <code>["self"]</code>, and <var>origin</var> is [same origin-domain]
        with <var>global</var>'s active document's origin, return
        "<code>Enabled</code>".
        </li>
        <li>Return "<code>Disabled</code>".</li>
      </ol>
    </section>
  </section>
  <section>
    <h2>IANA Considerations</h2>
    <p>The permanent message header field registry should be updated with the
    following registration [[!RFC3864]]:</p>
    <dl>
      <dt>Header field name</dt>
      <dd>Feature-Policy</dd>
      <dt>Applicable protocol</dt>
      <dd>http</dd>
      <dt>Status</dt>
      <dd>standard</dd>
      <dt>Author/Change controller</dt>
      <dd>W3C</dd>
      <dt>Specification document</dt>
      <dd>
        <a href="">Feature Policy API</a>
      </dd>
    </dl>
  </section>
  <section id="privacy" class="informative">
    <h2>Privacy and Security</h2>
    <p class="issue">TODO</p>
  </section>
  <section class="appendix">
    <h2>Features</h2>
    <p>This appendix is a reference to currently-defined valid <dfn data-lt=
    "feature">features</dfn>, their <dfn data-lt=
    "feature name|feature names|feature name keyword">feature name
    keywords</dfn>, and their effect when applied via a <a data-lt=
    "policy directive">directive</a> as part of a <a>feature policy</a>. This
    reference is non-normative; the actual definitions are given in subsections
    below.</p>
    <div class="issue">
      As soon as possible, move the definitions to their respective controlling
      specifications, and link to those specifications from this one. This spec
      shouldn't be required to enumerate every feature.
    </div>
    <table>
      <thead>
        <tr>
          <th>Feature name</th>
          <th>
            <a>Default whitelist</a>
          </th>
          <th>Brief description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <a>camera</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to video input devices.</td>
        </tr>
        <tr>
          <td>
            <a>eme</a>
          </td>
          <td><code>self</code></td>
          <td>Controls whether [requestMediaKeySystemAccess] is allowed.</td>
        </tr>
        <tr>
          <td>
            <a>fullscreen</a>
          </td>
          <td><code>self</code></td>
          <td>Controls whether [requestFullscreen] is allowed.</td>
        </tr>
        <tr>
          <td>
            <a>geolocation</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to [Geolocation interface].</td>
        </tr>
        <tr>
          <td>
            <a>microphone</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to audio input devices.</td>
        </tr>
        <tr>
          <td>
            <a>midi</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to [requestMIDIAccess method].</td>
        </tr>
        <tr>
          <td>
            <a>payment</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to [PaymentRequest interface].</td>
        </tr>
        <tr>
          <td>
            <a>speaker</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to audio output devices.</td>
        </tr>
        <tr>
          <td>
            <a>vibrate</a>
          </td>
          <td><code>self</code></td>
          <td>Controls access to [vibrate method].</td>
        </tr>
      </tbody>
    </table>
    <section>
      <h2>Feature Definitions</h2>
      <section>
        <h2><dfn>camera</dfn></h2>
        <p>The <a>camera</a> feature controls access to video input devices
        requested through the [NavigatorUserMedia interface]
        ([[!MEDIACAPTURE-API]]).</p>
        <p>If disabled in a document, then calls to getUserMedia() MUST NOT
        grant access to video input devices in that document.</p>
        <p>The <a>default whitelist</a> for <a>camera</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>eme</dfn></h2>
        <p>The <a>eme</a> keyword controls whether encrypted media extensions
        [[!encrypted-media]] are available.</p>
        <p>If disabled in a document, the promise returned by
        [requestMediaKeySystemAccess] must reject with a NotSupportedError.</p>
        <p>The <a>default whitelist</a> for <a>eme</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>fullscreen</dfn></h2>
        <p>The <a>fullscreen</a> keyword controls whether the
        [requestFullscreen] method ([[!WHATWG-FULLSCREEN]]) is allowed to
        request fullscreen.</p>
        <p>If disabled in any document, the document will not be allowed to use
        fullscreen. If enabled, the document will be allowed to use
        fullscreen.</p>
        <p>The <a>default whitelist</a> for <a>fullscreen</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>geolocation</dfn></h2>
        <p>The <a>geolocation</a> keyword controls whether the current document
        is alowed to use the [Geolocation interface]
        ([[!GEOLOCATION-API]]).</p>
        <p>If disabled in any document, calls to both getCurrentPosition and
        watchPosition must result in the error callback being invoked with
        PERMISSION_DENIED.</p>
        <p>The <a>default whitelist</a> for <a>geolocation</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>microphone</dfn></h2>
        <p>The <a>microphone</a> feature controls access to audio input devices
        requested through the [NavigatorUserMedia interface]
        ([[!MEDIACAPTURE-API]]).</p>
        <p>If disabled in a document, then calls to getUserMedia() MUST NOT
        grant access to audio input devices in that document.</p>
        <p>The <a>default whitelist</a> for <a>microphone</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>midi</dfn></h2>
        <p>The <a>midi</a> keyword controls whether the current document is
        allowed to use the [requestMIDIAccess method] ([[!WEBMIDI]]).</p>
        <p>If disabled in a document, the promise returned by requestMIDIAccess
        must reject with a DOMException parameter.</p>
        <p>The <a>default whitelist</a> for <a>midi</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>payment</dfn></h2>
        <p>The <a>payment</a> keyword controls whether the current document is
        allowed to use the [PaymentRequest interface]
        ([[!PAYMENT-REQUEST]]).</p>
        <p>If disabled in a document, then calls to the PaymentRequest
        constuctor MUST throw a SecurityError.</p>
        <p>The <a>default whitelist</a> for <a>payment</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>speaker</dfn></h2>
        <p>The <a>speaker</a> feature controls access to audio output devices
        requested through the [NavigatorUserMedia interface]
        ([[!audio-output]]).</p>
        <p>If disabled in a document, then calls to getUserMedia() MUST NOT
        grant access to audio output devices in that document.</p>
        <p>The <a>default whitelist</a> for <a>speaker</a> is
        <code>["self"]</code>.</p>
      </section>
      <section>
        <h2><dfn>vibrate</dfn></h2>
        <p>The <a>vibrate</a> keyword controls whether the [vibrate method]
        ([[!VIBRATION]]) is [exposed] for [current global object].</p>
        <p>If disabled in a document, then calls to the [vibrate method] should
        silently do nothing. If enabled, the browser may allow the device to
        vibrate.</p>
        <p>The <a>default whitelist</a> for <a>vibrate</a> is
        <code>["self"]</code>.</p>
      </section>
    </section>
  </section>
</body>
</html>

<!-- spec references. preserve before running tidy! -->
[sandbox attribute]: https://html.spec.whatwg.org/multipage/the-iframe-element.html#attr-iframe-sandbox
[sandbox directive]: https://www.w3.org/TR/2014/WD-CSP11-20140211/#sandbox
[window]: https://www.w3.org/TR/html5/browsers.html#dom-window
[workerglobalscope]: https://html.spec.whatwg.org/multipage/workers.html#workerglobalscope
[response]: https://fetch.spec.whatwg.org/#concept-response
[request]: https://fetch.spec.whatwg.org/#concept-request
[HTTPS state]: https://fetch.spec.whatwg.org/#concept-response-https-state
[origin]: https://url.spec.whatwg.org/#concept-url-origin
[url]: https://fetch.spec.whatwg.org/#concept-response-url
[potentially trustworthy]: https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
[header list]: https://fetch.spec.whatwg.org/#concept-response-header-list
[header]: https://fetch.spec.whatwg.org/#concept-header
[name]: https://fetch.spec.whatwg.org/#concept-header-name
[value]: https://fetch.spec.whatwg.org/#concept-header-value
[xhr-open]: https://xhr.spec.whatwg.org/#the-open()-method
[docwrite method]: https://html.spec.whatwg.org/#dom-document-write
[async]: https://html.spec.whatwg.org/#attr-script-async
[defer]: https://html.spec.whatwg.org/#attr-script-defer
[prepare a script]: https://html.spec.whatwg.org/#prepare-a-script
[non-blocking]: https://html.spec.whatwg.org/#non-blocking
[header-append]: https://fetch.spec.whatwg.org/#concept-header-list-append
[header-list]: https://fetch.spec.whatwg.org/#concept-request-header-list
[allowed to use]: https://html.spec.whatwg.org/multipage/embedded-content.html#allowed-to-use
[fetching algorithm]: https://fetch.spec.whatwg.org/#fetching
[global object]: https://html.spec.whatwg.org/multipage/webappapis.html#global-object
[current global object]: https://html.spec.whatwg.org/#current-global-object
[client]: https://fetch.spec.whatwg.org/#concept-request-client
[sender requirements]: https://greenbytes.de/tech/webdav/draft-ietf-httpbis-jfv-02.html#rfc.section.3
[non-blocking]: https://html.spec.whatwg.org/#non-blocking
[URL parser]: https://url.spec.whatwg.org/#concept-url-parser
[origin-of-url]: https://url.spec.whatwg.org/#concept-url-origin
[ascii case-insensitive]: https://html.spec.whatwg.org/multipage/infrastructure.html#ascii-case-insensitive
[document]: https://html.spec.whatwg.org/multipage/dom.html#document
[meta]: https://html.spec.whatwg.org/#the-meta-element
[http-equiv]: https://html.spec.whatwg.org/#attr-meta-http-equiv
[meta-content]: https://html.spec.whatwg.org/#attr-meta-content
[pragma directives]: https://html.spec.whatwg.org/#attr-meta-http-equiv-content-security-policy
[extended attribute]: https://heycam.github.io/webidl/#dfn-extended-attribute
[take an identifier]: https://heycam.github.io/webidl/#dfn-xattr-identifier
[global name]: https://heycam.github.io/webidl/#dfn-global-name
[exposed]: https://heycam.github.io/webidl/#dfn-exposed
[cookie attribute]: https://html.spec.whatwg.org/#dom-document-cookie
[domain attribute]: https://html.spec.whatwg.org/#dom-document-domain
[top-level browsing context]: https://html.spec.whatwg.org/#top-level-browsing-context
[nested browsing context]: https://html.spec.whatwg.org/#nested-browsing-context
[document.write]: https://html.spec.whatwg.org/#dom-document-write
[document.writeln]: https://html.spec.whatwg.org/#dom-document-writeln
[requestFullscreen]: https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen
[Geolocation interface]: https://www.w3.org/TR/geolocation-API/#geolocation_interface
[NavigatorUserMedia interface]: https://w3c.github.io/mediacapture-main/#navigatorusermedia
[RTCPeerConnection interface]: http://w3c.github.io/webrtc-pc/#rtcpeerconnection-interface
[Notification interface]: https://www.w3.org/TR/notifications/#notification
[PaymentRequest interface]: https://www.w3.org/TR/payment-request/#paymentrequest-interface
[PushManager interface]: https://w3c.github.io/push-api/#idl-def-PushManager
[requestMIDIAccess method]: http://webaudio.github.io/web-midi-api/#requestMIDIAccess
[vibrate method]: https://w3c.github.io/vibration/#idl-def-navigator-vibrate(vibratepattern)
[same origin-domain]: https://html.spec.whatwg.org/#same-origin-domain
[VRDisplay interface]: https://w3c.github.io/webvr/#interface-vrdisplay
[WebVR]: https://w3c.github.io/webvr/
[requestMediaKeySystemAccess]: https://www.w3.org/TR/encrypted-media/#navigator-extension-requestmediakeysystemaccess
