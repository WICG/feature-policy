<!DOCTYPE html>
<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 for Mac OS X version 5.1.25">
  <title>Feature Policy</title>
  <meta charset='utf-8'>
  <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class=
  'remove'>
  </script>
  <script class='remove'>
  var respecConfig = {
    shortName: "feature-policy",
    specStatus: "CG-DRAFT",
    useExperimentalStyles: true,
    edDraftURI: "http://wicg.github.io/feature-policy/",
    editors: [{
      name: "Ilya Grigorik",
      url: "https://www.igvita.com/",
      mailto: "igrigorik@gmail.com",
      company: "Google",
      companyURL: "https://google.com/",
      w3cid: "56102"
    }, {
      name: "Mike West",
      mailto: "mkwst@google.com",
      company: "Google",
      companyURL: "https://google.com/",
      w3cid: "56384"
    }],
    wg: "WICG",
    subjectPrefix: "[feature-policy]",
    format: "markdown",
    // noLegacyStyle: true,
    otherLinks: [{
      key: 'Repository',
      data: [{
        value: 'We are on Github.',
        href: 'https://github.com/wicg/feature-policy/'
      }, {
        value: 'File a bug.',
        href: 'https://github.com/wicg/feature-policy/issues'
      }, {
        value: 'Commit history.',
        href: 'https://github.com/wicg/feature-policy/commits/gh-pages/index.html'
      }]
    }],
    localBiblio:  {
      'PERMISSION-DELEGATION': {
        title: 'Permission Delegation To Embedded Web Applications',
        href: 'https://noncombatant.github.io/permission-delegation-api/',
        authors: [
          'Raymes Khoury',
          'Chris Palmer'
        ],
        date: 'March 30 2016'
      },
      'HTTP-JFV': {
        title: 'A JSON Encoding for HTTP Header Field Values',
        href: 'https://greenbytes.de/tech/webdav/draft-ietf-httpbis-jfv-02.html',
        authors: [
          'Julian Reschke'
        ],
        date: 'October 24 2016'
      }
    }
  };
  </script>
  <style>
    table {
      border-collapse: collapse;
      border-style: hidden hidden none hidden;
    }
    table td, table th {
      border-left: solid;
      border-right: solid;
      border-bottom: solid thin;
      vertical-align: top;
      padding: 0.2em;
    }
    th {
      background-color: #ccc;
    }
  </style>
</head>
<body>
  <section id='abstract'>
    <p>This specification defines a mechanism that allows developers to
    selectively enable and disable use of various browser features and
    APIs.</p>
  </section>
  <section id='sotd'>
    <p>This is a <strong>work in progress</strong> and may change without any
    notices.</p>
  </section>
  <section>
    <h2>Introduction</h2>
    <p>The web-platform provides an ever-expanding set of features and APIs,
    offering richer functionality, better developer ergonomics, and improved
    performance. However, a missing piece is the ability for the developer to
    selectively enable, disable, or modify the behavior of some of these
    browser features and APIs within their application:</p>
    <ol>
      <li>The developer may want to selectively _disable_ access to certain
      browser features and APIs to "lock down" their application, as a security
      or performance precaution, to prevent own and third-party content
      executing within their application from introducing unwanted or
      unexpected behaviors within their application.</li>
      <li>The developer may want to selectively _enable_ access to certain
      browser features and APIs which may be disabled by default - e.g. some
      features may be disabled by default in embedded context unless explicitly
      enabled; some features may be subject to other policy requirements.</li>
      <li>The developer may want to use the policy to assert a promise to a
      client or an embedder about the use—or lack of thereof—of certain
      features and APIs. For example, to enable certain types of "fast path"
      optimizations in the browser, or to assert a promise about conformance
      with some requirements set by other embedders - e.g. various social
      networks, search engines, and so on.</li>
    </ol>
    <p>This specification defines a feature policy mechanism that addresses the
    above use cases.</p>
    <section>
      <h2>Examples</h2>
      <div class="example">
        <p>SecureCorp Inc. wants to disable use of WebRTC and Geolocation APIs
        within their application. It can do so by delivering the following HTTP
        response header to define a feature policy:</p>
        <pre><a>Feature-Policy</a>: {"<a>webrtc</a>": [], "<a>geolocation</a>": []}</pre>
        <p>By specifying an empty list of origins, the specified features will
        be disabled for all browsing contexts, regardless of their origin.</p>
      </div>
      <div class="example">
        <p>SecureCorp Inc. wants to disable use of Geolocation API within all
        browsing contexts except for its own origin and those whose origin is
        "`https://example.com`". It can do so by delivering the following HTTP
         response header to define a feature
        policy:</p>
        <pre><a>Feature-Policy</a>: {"<a>geolocation</a>": ["<a>self</a>", "https://example.com"]}</pre>
        <p>The <a>origin list</a> is a list of one or more origins, which can
        include the application's origin, optionally with the keyword
        "<a>self</a>", and any third-party origin.</p>
      </div>
      <div class="example">
        <p>SecureCorp Inc. is hosting an application on "`https://example.com`"
        and wants to disable WebRTC on its own origin but enable it for a
        whitelisted embedee ("`https://other.com`"). It can do so by delivering
        the following HTTP response header to define a feature policy:</p>
        <pre><a>Feature-Policy</a>: {"<a>webrtc</a>": ["https://other.com"]}</pre>
        <p>Some features are disabled by default in embedded contexts. The
        enable policy allows the application to selectively enable such
        features for whitelisted origins.</p>
      </div>
      <div class="example">
        <p>FastCorp Inc. wants to disable use of synchronous `script` elements,
        synchronous `XMLHttpRequest`'s and use of `document.write` within their
        application. It can do so by delivering the following HTTP response
        header to define a feature policy:</p>
        <pre><a>Feature-Policy</a>: {"<a>sync-xhr</a>": [],"<a>sync-script</a>": [],"<a>docwrite</a>": []}</pre>
      </div>
    </section>
    <section>
      <h2>Other and related mechanisms</h2>
      <p>[[HTML5]] defines a [sandbox attribute] for `iframe` elements that
      allows developers to reduce the risk of including potentially untrusted
      content by imposing restrictions on content's abilities - e.g. prevent it
      from submitting forms, running scripts and plugins, and more. The
      [sandbox directive] defined by [[CSP2]] extends this capability to any
      resource, framed or not, to ask for the same set of restrictions - e.g.
      via an HTTP response header (`Content-Security-Policy: sandbox`). These
      mechanisms enable the developer to:</p>
      <ul>
        <li>Set and customize a sandbox policy on any resource via CSP.</li>
        <li>Set and customize individual sandbox policies on each `iframe`
        element within their application.</li>
      </ul>
      <p>However, there are several limitations to the above mechanism: the
      developer cannot automatically apply a policy across all contexts, which
      makes it hard or impossible to enforce consistently in some cases (e.g.
      due to third-party content injecting frames, which the developer does not
      control); there is no mechanism to selectively enable features that may
      be off by default; the sandbox mechanism uses a whitelist approach which
      is impossible to extend without compatibility risk.</p>
      <p>Feature Policy is intended to be used in combination with the sandbox
      mechanism (i.e. it does not duplicate feature controls already covered by
      sandbox), and provides an extensible mechanism that addresses the above
      limitations.</p>
    </section>
  </section>
  <section>
    <h2>Framework</h2>
    <section>
      <h2>Policies</h2>
      <p>A <dfn>feature policy</dfn> may be applied to a [Document] or
      [WorkerGlobalScope] and consists of:</p>
      <ul>
        <li>A set of <a data-lt="inherited policies">inherited policies</a>.
        </li>
        <li>A set of <a data-lt="declared policy">declared policies</a>.
        </li>
      </ul>
    </section>
    <section>
      <h2>Inherited policies</h2>
      <p>Each document in a frame tree inherits a set of policies from its
      parent frame, or in the case of the top-level document, from the defined
      defaults for each feature. This inherited policy set determines the
      initial state (enabled or disabled) of each feature, and whether it can be
      controlled by a <a>declared policy</a> in the document.</p>
      <p>In a top-level document, or a [WorkerGlobalScope], the inherited
      feature set is based on defined defaults for each feature.<p>
      <p>In a document in an nested browsing context, the inherited feature set
      is based on the parent document's feature policy, as well as any allow
      attributes defined on the browsing context container.</p>
      <p>An <dfn>inherited policy</dfn> for a <a>feature</a> is a boolean
      associated with that feature in a Document or WorkerGlobalScope. It can
      take the value Enabled or Disabled.</p>
      <p>An <dfn>inherited policy set</dfn> for a Document or WorkerGlobalScope
      is the set of <a>inherited policies</a> for each <a>feature</a> available
      in that scope.</p>
    </section>
    <section>
      <h2>Declared policies</h2>
      <p>A <dfn>declared policy</dfn> is a set of <a>policy directives</a>.
      <p>The declared policy is represented in HTTP headers and HTML attributes as a JSON string.
    </section>
    <section>
      <h2>Policy directives</h2>
      <p>A <dfn>policy directive</dfn> is a dictionary, mapping <a>feature
        names</a> to corresponding <a>whitelists</a> of origins.</p>
      <p>The following sections define the set of known <a>feature names</a>.
      Future versions of this document may define
      additional such names and user agents MUST ignore policy directives with
      unrecognized names when parsing the policy.</p>
      </section>
    <section>
      <h2>Whitelists</h2>
      <p>A feature policy <dfn>whitelist</dfn> is a set of <a>origins</a>. A
      <a>whitelist</a> may be <em>empty</em>, in which case it does not match
      any origin, or it may contain a list of origins, or it may match every
      origin. When defining a whitelist in a policy, the special origin "self"
      may be used. In an HTTP header, "self" refers to the origin of the
      document which the header is associated with. In an iframe attribute,
      "self" refers to the origin of the URL in the iframe element's src
      attribute.</p>
    </section>
  </section>
  <section>
    <h2>Feature Policy Serialization</h2>
    <section>
      <h2>JSON Serialization</h2>
      <p>Declared Policies are represented in HTTP headers and in HTML attributes as JSON strings. The structure of the JSON string is as follows:
      <p>A feature policy JSON serialization is the JSON encoding of a list of policy directives
      <p>A policy directive is an object, whose keys are the string names of features, and whose values are whitelists.
      <p>A whitelist is a array of strings, each of which may be an origin, the string "\\*", or the string "self".
      <p>Origins are represented by their ASCII serialization.
      <p>The string "self" may be used as an origin. In this case, it will refer to the origin of the document
      which contains the Feature Policy.
      <div class="example">
        Include an example here
      </div>
    </section>
  </section>
  <section>
    <h2>Delivery</h2>
    <section>
      <h2>`Feature-Policy` HTTP Header Field</h2>
      <p>The <dfn>Feature-Policy</dfn> HTTP header field can be used in the
      [response] (server to client) to communicate the <a>feature policy</a>
      that should be enforced by the client.</p>
      <p>The header's value is the JSON serialization of the <a>declared policy</a>:
      </p>
      <pre class="abnf">
        FeaturePolicy = 1#json-field-value
                  ; See Section 2 of [[HTTP-JFV]], and Section 2 of [[RFC7159]]
      </pre>
      <p>When the user agent receives a `Feature-Policy` header field, it
      MUST <a href="#process-response-policy">process</a> and <a>enforce</a>
      the serialized policy as described in <a href=
      "#integration-with-html"></a>. When the user agent [performs a
      fetch][fetching algorithm], it MUST advertise the active <a>feature
      policy</a> as described in <a href="#integration-with-fetch"></a>.</p>
      <h2>Process response policy</h2>
      <p>Given a [response] (<var>response</var>) and [global object]
      (<var>global</var>), this algorithm returns a <a>feature
      policy</a>.</p>
      <ol>
        <li>Abort these steps if the <var>response</var>’s [header list] does
        not contain a [header] whose [name] is "`Feature-Policy`".</li>
        <li>Let <var>header</var> be the [value] of the [header] in
        <var>response</var>’s [header list] whose name is
        "`Feature-Policy`".</li>
        <li>Let <var>feature policy</var> be the result of executing
          <a href="#parse-policy-from-value-and-global"></a> on
          <var>header</var> and <var>global</var>.
        </li>
      </ol>
    </section>
    <section>
      <h2>The `featurepolicy` attribute of the `iframe` element</h2>
      <p>Iframe elements may have an "feature" attribute, which contains a space-separated list of feature names.
    </section>
    <section>
      <h2>The `allow` attribute of the `iframe` element</h2>
      <p>Iframe elements may have an "allow" attribute, which contains a space-separated list of feature names.
    </section>
    <section>
      <h2>Additional attributes to support legacy features</h2>
      <p>Some features controlled by Feature Policy have existing...
      <section>
        <h3>allowfullscreen</h3>
        <p>The "`allowfullscreen`" iframe attribute controls access to [Fullscreen interface].
      </section>
      <section>
        <h3>allowpaymentrequest</h3>
      </section>
      <section>
        <h3>allowusermedia</h3>
      </section>
    </section>
    <section>
      <h2>Parse policy from <var>value</var> and <var>global</var></h2>
      <p>Given a string (<var>value</var>) and [global object]
      (<var>global</var>) this algorithm will return a <a>feature
      policy</a>.</p>
      <p>Given a string (value) and global object (global) this algorithm will return a declared feature policy.</p>
      <ol>
        <li>Let policy be an empty list.</li>
        <li>Let list be the result of executing the algorithm defined in Section 4 of [HTTP-JFV] on value. If that algorithm results in an error, return policy.</li>
        <li>For each directive in list:</li>
        <ol>
          <li>If directive is not an object, abort these steps and continue with the next item.</li>
          <li>For each key and associated targetlist in directive:</li>
          <ol>
            <li>If key is not equal to the name of any recognized feature, abort these steps and continue with the next key and targetlist.</li>
            <li>If targetlist is not an array, abort these steps and continue with the next key and targetlist.</li>
            <li>Let whitelist be a new whitelist.</li>
            <li>If targetlist contains the string "`\*`", set whitelist to match every origin.</li>
            <li>Otherwise, for each origin in targetlist:</li>
            <ol>
              <li>If origin is an ASCII case-insensitive match for "`self`", let result be global's origin.</li>
              <li>Otherwise, let result be the result of executing the URL parser on origin.</li>
              <li>If result is not failure:</li>
              <ol>
                <li>Let target be the origin of result.</li>
                <li>If target is not an opaque origin, append target to whitelist.</li>
              </ol>
            </ol>
            <li>Append whitelist to policy.</li>
          </ol>
          <li>Return policy.</li>
        </ol>
      </ol>
    </section>
  </section>
  <section>
    <h2>Features</h2>
    <p>This section defines <dfn>features</dfn> and their effect when applied
    via a <a>directive</a> as part of a <a>feature policy</a>.</p>
    <p>The following table summarizes <a>features</a> defined by this
    specification, by their corresponding keywords. This table is
    non-normative; the actual definitions are given in the following
    sections.</p>
    <table>
      <thead>
        <tr>
          <th>Feature name</th>
          <th>
            <a>Default policy</a>
          </th>
          <th>Brief description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <a>cookie</a>
          </td>
          <td>`\*`</td>
          <td>Controls access to `document.cookie`.</td>
        </tr>
        <tr>
          <td>
            <a>domain</a>
          </td>
          <td>`\*`</td>
          <td>Controls access to `document.domain`.</td>
        </tr>
        <tr>
          <td>
            <a>docwrite</a>
          </td>
          <td>`\*`</td>
          <td>Controls access to `document.write`, `document.writeln`.</td>
        </tr>
        <tr>
          <td>
            <a>fullscreen</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [Fullscreen interface].</td>
        </tr>
        <tr>
          <td>
            <a>geolocation</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [Geolocation interface].</td>
        </tr>
        <tr>
          <td>
            <a>midi</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [requestMIDIAccess method].</td>
        </tr>
        <tr>
          <td>
            <a>notifications</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [Notification interface].</td>
        </tr>
        <tr>
          <td>
            <a>payment</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [PaymentRequest interface].</td>
        </tr>
        <tr>
          <td>
            <a>push</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [PushManager interface].</td>
        </tr>
        <tr>
          <td>
            <a>sync-script</a>
          </td>
          <td>`\*`</td>
          <td>Controls use of synchronous `script` elements.</td>
        </tr>
        <tr>
          <td>
            <a>sync-xhr</a>
          </td>
          <td>`\*`</td>
          <td>Controls access to synchronous `XMLHttpRequest` API.</td>
        </tr>
        <tr>
          <td>
            <a>usermedia</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [NavigatorUserMedia interface].</td>
        </tr>
        <tr>
          <td>
            <a>vibrate</a>
          </td>
          <td>`self`</td>
          <td>Controls access to [vibrate method].</td>
        </tr>
        <tr>
          <td>
            <a>webrtc</a>
          </td>
          <td>`\*`</td>
          <td>Controls access to [RTCPeerConnection interface].</td>
        </tr>
        <tr>
          <td>
            <a>webvr</a>
          </td>
          <td>`\*`</td>
          <td>Controls access to [VRDisplay interface].</td>
        </tr>
      </tbody>
    </table>
    <section>
      <h2><dfn>`cookie`</dfn></h2>
      <pre class="idl">
partial interface Document {
  [Feature=cookie] attribute USVString cookie;
};</pre>
        <p>The <a>cookie</a> keyword controls whether the [cookie attribute] is
        [exposed] for [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `\*` for [top-level browsing
          context], and `\*` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`domain`</dfn></h2>
        <pre class="idl">
partial interface Document {
  [Feature=domain] attribute USVString domain;
};</pre>
        <p>The <a>domain</a> keyword controls whether the [domain attribute] is
        [exposed] for [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `\*` for [top-level browsing
          context], and `\*` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`docwrite`</dfn></h2>
        <pre class="idl">
partial interface Document {
  [CEReactions, Feature=docwrite] void write(DOMString... text);
  [CEReactions, Feature=docwrite] void writeln(DOMString... text);
};</pre>
        <p>The <a>docwrite</a> keyword controls whether the [document.write]
        and [document.writeln] methods are [exposed] for [current global
        object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `\*` for [top-level browsing
          context], and `\*` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`geolocation`</dfn></h2>
        <pre class="idl">
partial interface Navigator {
  [Feature=geolocation] readonly attribute Geolocation geolocation;
};</pre>
        <p>The <a>geolocation</a> keyword controls whether the [Geolocation
        interface] ([[!GEOLOCATION-API]]) is [exposed] for [current global
        object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`midi`</dfn></h2>
        <pre class="idl">
partial interface Navigator {
  [Feature=midi] Promise&lt;MIDIAccess&gt; requestMIDIAccess (optional MIDIOptions options);
};</pre>
        <p>The <a>midi</a> keyword controls whether the [requestMIDIAccess
        method] ([[!WEBMIDI]]) is [exposed] for [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`notifications`</dfn></h2>
        <pre class="idl">
[Constructor(DOMString title, optional NotificationOptions options),
Feature=notifications]
interface Notification : EventTarget {};</pre>
        <p>The <a>notifications</a> keyword controls whether the [Notification
        interface] ([[!NOTIFICATIONS]]) is [exposed] for [current global
        object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`payment`</dfn></h2>
        <pre class="idl">
[Constructor(sequence&lt;PaymentMethodData&gt; methodData, PaymentDetails details, optional PaymentOptions options),
 SecureContext, Feature=payment]
interface PaymentRequest : EventTarget {};</pre>
        <p>The <a>payment</a> keyword controls whether the [PaymentRequest
        interface] ([[!PAYMENT-REQUEST]]) is [exposed] for [current global
        object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`push`</dfn></h2>
        <pre class="idl">
partial interface ServiceWorkerRegistration {
  [Feature=push] readonly attribute PushManager pushManager;
};

[Feature=push]
interface PushManager {};
</pre>
        <p>The <a>push</a> keyword controls whether the [PushManager interface]
        ([[!PUSH-API]]) is [exposed] for [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`sync-script`</dfn></h2>
        <p>The <a>sync-script</a> keyword controls use of synchronous `script`
        elements, as defined in <a href="#integration-with-html"></a>. When
        this feature is disabled, such scripts are ignored by the user
        agent.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>sync-script</a>"]}</pre>
          <p>The following HTML will not result in execution of `script1.js`,
          as it has neither a [`defer`] nor an [`async`] attribute. The
          remaining scripts will execute normally because they have their
          [non-blocking] flag set.</p>
          <pre>
  &lt;script src="/script1.js"&gt;&lt;/script&gt;
  &lt;script src="/script2.js" <strong>async</strong>&gt;&lt;/script&gt;
  &lt;script src="/script3.js" <strong>defer</strong>&gt;&lt;/script&gt;
  &lt;script&gt;
    const scriptEl = document.createElement("script");
    scriptEl.src = "/script4.js";
    document.body.appendChild(scriptEl);
  &lt;/script&gt;</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`sync-xhr`</dfn></h2>
        <p>The <a>sync-xhr</a> keyword controls use of synchronous
        `XMLHttpRequest` API, as defined in <a href=
        "#integration-with-xmlhttprequest"></a>. When [open() method](xhr-open)
        is called with <var>async</var> argument set to <var>false</var>, an
        `InvalidAccessError` except will be thrown.</p>
        <div class="example">
          <p>Given the following header:</p>
          <pre>
  <a>Feature-Policy</a>: {"<a data-lt=
"disable member">disable</a>":["<a>sync-xhr</a>"]}</pre>
          <p>The following JavaScript code will throw a `InvalidAccessError`
          exception:</p>
          <pre>
  var xhr = new XMLHttpRequest();
  xhr.open("GET", "/foo", false);</pre>
        </div>
      </section>
      <section>
        <h2><dfn>`usermedia`</dfn></h2>
        <pre class="idl">
[Exposed=Window, NoInterfaceObject, Feature=usermedia]
interface NavigatorUserMedia {
    [SameObject] readonly attribute MediaDevices mediaDevices;
};</pre>
        <p>The <a>usermedia</a> keyword controls whether the
        [NavigatorUserMedia interface] ([[!MEDIACAPTURE-API]]) is [exposed] for
        [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`vibrate`</dfn></h2>
        <pre class="idl">
partial interface Navigator {
  [Feature=vibrate] boolean vibrate(VibratePattern pattern);
};</pre>
        <p>The <a>vibrate</a> keyword controls whether the [vibrate method]
        ([[!VIBRATION]]) is [exposed] for [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `self` for [top-level
          browsing context], and `null` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
      <section>
        <h2><dfn>`webrtc`</dfn></h2>
        <pre class="idl">
[Constructor(optional RTCConfiguration configuration), Feature=webrtc]
interface RTCPeerConnection : EventTarget {};</pre>
        <p>The <a>webrtc</a> keyword controls whether the [RTCPeerConnection
        interface] ([[!WEBRTC]]) is [exposed] for [current global object].</p>
        <ol>
          <li>The default <a>enable policy</a> is `\*` for [top-level browsing
          context], and `\*` for [nested browsing context].
          </li>
          <li>The default <a>disable policy</a> is `null`.
          </li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>Disable Policy</h2>
    <p>The <dfn>disable policy</dfn> allows a developer to turn off certain
    features for a <code>Document</code> or <code>Worker</code>.</p>
    <section>
      <h2>Processing</h2>
      <section>
        <h2>Parse disable features</h2>
        <p>Given a <var>list</var>, this algorithm returns a list of
        <a>features</a>, which may be empty.</p>
        <ol>
          <li>Let <var>valid-features</var> be an empty list.</li>
          <li>If <var>list</var> is <var>null</var> or empty, return
          <var>valid-features</var>.</li>
          <li>For each <var>item</var> in <var>list</var>:
            <ol>
              <li>Convert <var>item</var> to ASCII-lowercase.</li>
              <li>If <var>item</var>'s string value is not one of the
              <a>features</a>, ignore <var>item</var>, and continue to the next
              item.
              </li>
              <li>Append <var>item</var> to <var>valid-features</var>.</li>
            </ol>
          </li>
          <li>Return <var>valid-features</var>.</li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>Enable Policy</h2>
    <p>The <dfn>enable policy</dfn> allows a developer to turn on certain
    features for a <code>Document</code> or <code>Worker</code>.</p>
    <section>
      <h2>Processing</h2>
      <section>
        <h2>Parse enable features</h2>
        <p>Given a <var>list</var>, this algorithm returns a list of
        <a>features</a>, which may be empty.</p>
        <ol>
          <li>Let <var>valid-features</var> be an empty list.</li>
          <li>If <var>list</var> is <var>null</var> or empty, return
          <var>valid-features</var>.</li>
          <li>For each <var>item</var> in <var>list</var>:
            <ol>
              <li>Convert <var>item</var> to ASCII-lowercase.</li>
              <li>TODO... should we merge/refactor this with disable
              parse?</li>
              <li>Append <var>item</var> to <var>valid-features</var>.</li>
            </ol>
          </li>
          <li>Return <var>valid-features</var>.</li>
        </ol>
      </section>
    </section>
  </section>
  <section>
    <h2>Integrations</h2>
    <p>This document defines a set of algorithms which other specifications
    will use in order to implement the restrictions which Feature Policy
    defines. The integrations are outlined here for clarity, but those external
    documents are the normative references which ought to be consulted for
    detailed information.</p>
    <section>
      <h3>Integration with HTML</h3>
      <ol>
        <li>
          <code>Document</code> and <code>WorkerGlobalScope</code> objects have
          a <dfn>Feature Policy List</dfn>, which is either the empty set or a
          <a>feature policy</a>. This property is the empty set unless
          otherwise specified, and is populated via the <a href=
          "#initialize-for-global"></a> algorithm that is called during the
          "Initialising a new <code>Document</code> object" and "Run a Worker"
          algorithms.
        </li>
        <li>A <a>feature policy</a> is <dfn data-lt="enforce">enforced</dfn>
        for a [global object] by inserting it into the [global object]'s
        <a>Feature Policy list</a>.
        </li>
        <li>
          <a>Feature policy</a> is enforced during <a href=
          "#process-meta-policy">processing of the meta element’s
          http-equiv</a>.
        </li>
        <li>
          <p>The "[prepare a script]" algorithm calls into <a href=
          "#is-feature-disabled"></a> algorithm to determine whether or not to
          execute a script, as follows:</p>
          <ol>
            <li>Add the following step before the current step 10 (which is the
            first of several "disabled" checks):
              <ol>
                <li>If the `script` element's "`non-blocking`" flag is unset,
                the `script`'s type is "`classic`", and the <a href=
                "#is-feature-disabled"></a> algorithm returns "`Disabled`" when
                executed upon the `script` element's node document's global
                object, then abort these steps at this point. The script is not
                executed.
                </li>
              </ol>
            </li>
          </ol>
        </li>
      </ol>
      <div class="issue">
        Monkey-patching! As soon as we know that this is the direction we wish
        to persuse, upstream all of this.
      </div>
      <section>
        <h4 id="initialize-for-global">Initialize <var>global</var>'s Feature
        Policy from <var>response</var></h4>
        <p>Given a [response] (<var>response</var>) and a global object
        (<var>global</var>), this algorithm populates <var>global</var>'s
        <a>Feature Policy List</a></p>
        <ol>
          <li>If <var>global</var> is a `Window` and its `Document` has a
          parent browsing context or opener browsing context
          (<var>context</var>):
            <ol>
              <li>Let <var>document</var> be the active document in
              <var>context</var>.</li>
              <li>For each <var>directive</var> in <var>document</var>'s
              <a>Feature Policy List</a>:
                <ol>
                  <li>Add <var>directive</var> to <var>global</var>'s
                  `Document`'s <a>Feature Policy List</a> if any of the
                  following are true:
                    <ol>
                      <li>
                        <var>directive</var>'s <a>target</a> is "`\*`"
                      </li>
                      <li>
                        <var>directive</var>'s <a>target</a> is an array
                        containing <var>global</var>'s origin
                      </li>
                      <li><var>response</var>'s url's scheme is a local
                      scheme</li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>If <var>global</var> is a `WorkerGlobalScope`:
            <ol>
              <li>For each <var>document</var> in <var>global</var>'s
                <a href="https://html.spec.whatwg.org/multipage/workers.html#the-worker's-documents">
                documents</a>:
                <ol>
                  <li>For each <var>directive</var> in <var>document</var>'s
                  <a>Feature Policy List</a>:
                    <ol>
                      <li>Add <var>directive</var> to <var>global</var>'s
                      <a>Feature Policy List</a> if either of the following are
                      true:
                        <ol>
                          <li>
                            <var>directive</var>'s <a>target</a> is "`\*`"
                          </li>
                          <li>
                            <var>directive</var>'s <a>target</a> is an array
                            containing <var>global</var>'s origin
                          </li>
                          <li><var>response</var>'s url's scheme is a local
                          scheme</li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Let <var>policy</var> be the result of executing <a href=
          "#process-response-policy"></a> on <var>response</var> and
          <var>global</var>.
          </li>
          <li>
            <a>Enforce</a> the policy <var>policy</var>.
          </li>
        </ol>
      </section>
      <section>
        <h4 id="define-inherited-policy">Define an inherited policy for <var>feature</var></h4>
        <p>Given a string (<var>feature</var>) and a browsing context (<var>context</var>), this algorithm returns the inherited policy for that feature.
        <ol>
          <li>If <var>context</var> is a <a>nested browsing context</a>:
            <ol>
              <li>let <var>parent</var> be <var>context</var>'s parent browsing context's active document.</li>
              <li>If <var>feature</var> is not <a>enabled by</a> <var>parent</var>'s feature policy, for <var>parent</var>'s origin, return Disabled.</li>
              <li>Let <var>container policy</var> be the result of running <a>parse feature policy declaration</a> on the value of the `featurepolicy` attribute of <var>context</var>'s browsing context container.</li>
              <li>Otherwise, if <var>feature</var> is a key in <var>container policy</var>:
                <ol>
                  <li>If the <a>whitelist</a> for <var>feature</var> in <var>container policy</var> contains <var>origin</var>, return Enabled.</li>
                  <li>Otherwise return Disabled.</li>
                </ol>
              </li>
              <li>Let <var>allowed features</var> be the result of parsing the value of the `enable` attribute of <var>context</var>'s browsing context container.</li>
              <li>If <var>feature</var> is in <var>allowed features:
                <ol>
                  <li>If <var>origin</var> is same origin-domain with matches the origin of the URL in the `src` attribute of <var>context</var>'s browsing context container, return Enabled</li>
                </ol>
              </li>
              <li>Otherwise, if feature is allowed by the parent frame’s policy for origin, return Enabled.</li>
              <li>Otherwise, return Disabled.</li>
            </ol>
          </li>
          <li>Otherwise, return Enabled.</li>
        </ol>
      </section>
      <section>
        <h4 id="is-feature-disabled">Is <var>feature</var> disabled for
        <var>global</var>?</h4>
        <p>Given a string (<var>feature</var>) and a global object
        (<var>global</var>), this algorithm returns "`Disabled`" if
        <var>feature</var> should be considered disabled, and "`Enabled`"
        otherwise.</p>
        <ol>
          <li>Let <var>policy</var> be <var>global</var>'s <a>Feature Policy
          List</a>
          </li>
          <li>If <var>policy</var> is empty, return "`Enabled`".</li>
          <li>For each <var>directive</var> in <var>policy</var>:
            <ol>
              <li>If <var>directive</var>'s <a>disable</a> contains
              <var>feature</var>:
                <ol>
                  <li>Return "`Disabled`".</li>
                </ol>
              </li>
            </ol>
          </li>
          <li>Return "`Enabled`".</li>
        </ol>
      </section>
      <section>
        <h4>Allowed to use</h4>
        <p>check the feature policy</p>
      </section>
    </section>
    <section>
      <h2>Integration with Fetch</h2>
      <section>
        <h2>Set request policy</h2>
        <p>This monkey patches [fetching algorithm], by inserting the following
        steps after current step #4:</p>
        <ol>
          <li>If [request]'s [client] is not <var>null</var> and has a
          non-empty <a>feature policy list</a>, run the following steps:
            <ol>
              <li>Let <var>policy</var> be the [current global object]'s
              <a>feature policy list</a>.
              </li>
              <li>Let <var>serialized feature policy</var> be the result of
              executing the [sender requirements] algorithm on
              <var>policy</var>, as defined in section 3 of [[!HTTP-JFV]].</li>
              <li>[Append](header-append) <var>Feature-Policy/serialized
              feature policy</var> to request's [header list].</li>
            </ol>
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>Integration with XMLHttpRequest</h2>
      <p>The `open() method` calls into the <a href="#is-feature-disabled"></a>
      algorithm to determine whether or not to throw, as follows:</p>
      <ol>
        <li>Add the following step after the current step 3:
          <ol>
            <li>If <var>async</var> is <var>false</var> and the <a href=
            "#is-feature-disabled"></a> algorithm returns "`Disabled`" when
            executed upon "`sync-xhr`" and the document's global object, throw
            "`InvalidAccessError`" exception.
            </li>
          </ol>
        </li>
      </ol>
    </section>
    <section>
      <h2>Integration with WebIDL</h2>
      <p>This section defines an extended attribute whose presence affects only
      the ECMAScript binding.</p>
      <section>
        <h2>[Feature]</h2>
        <p>If the <dfn>[Feature]</dfn> [extended attribute] appears on an
        interface, partial interface, or an individual interface member, it
        indicates that the interface or interface member is subject to
        <a>feature policy</a> associated with the ECMAScript global
        environment's global object.</p>
        <p>The <a>[Feature]</a> [extended attribute] must [take an identifier],
        which must be a [global name].</p>
        <p>Whether a construct that the <a>[Feature]</a> [extended attribute]
        can be specified on is <dfn>enabled by feature policy for global</dfn>
        is defined as follows:</p>
        <ol>
          <li>If the <a>[Feature]</a> [extended attribute] is specified on the
          construct, then it is <a>enabled by feature policy for global</a> if
          the "<a href="#is-feature-disabled">is feature disabled for
          global?</a>" algorithm returns "`Enabled`" when executed upon the
          extended attribute's argument and the ECMAScript global environment's
          global object.
          </li>
          <li>Otherwise, if the <a>[Feature]</a> [extended attribute] does not
          appear on a construct, then it is <a>enabled by feature policy for
          global</a>, depending on the type of construct:
            <ol>
              <li>**Interface**: the interface or dictionary is implicity
              "`Enabled`" by feature policy.</li>
              <li>**Partial interface**: the partial interface is <a>enabled by
              feature policy for global</a> if and only if the original
              interface definition is.
              </li>
              <li>**Interface member**: the interface member is <a>enabled by
              feature policy for global</a> if and only if the interface or
              partial interface the member is declared on is.
              </li>
            </ol>
          </li>
        </ol>
        <p class="note">Whether a construct is <a>enabled by feature policy for
        global</a> influences whether it is [exposed] in a given ECMAScript
        global environment.</p>
      </section>
    </section>
  </section>
  <section>
    <h2>IANA Considerations</h2>
    <p>The permanent message header field registry should be updated with the
    following registration [[!RFC3864]]:</p>
    <dl>
      <dt>Header field name</dt>
      <dd>Feature-Policy</dd>
      <dt>Applicable protocol</dt>
      <dd>http</dd>
      <dt>Status</dt>
      <dd>standard</dd>
      <dt>Author/Change controller</dt>
      <dd>W3C</dd>
      <dt>Specification document</dt>
      <dd>
        <a href="">Feature Policy API</a>
      </dd>
    </dl>
  </section>
  <section id="privacy" class="informative">
    <h2>Privacy and Security</h2>
    <p class="issue">TODO</p>
  </section>
</body>
</html>

<!-- spec references. preserve before running tidy! -->
[sandbox attribute]: https://html.spec.whatwg.org/multipage/the-iframe-element.html#attr-iframe-sandbox
[sandbox directive]: https://www.w3.org/TR/2014/WD-CSP11-20140211/#sandbox
[window]: https://www.w3.org/TR/html5/browsers.html#dom-window
[workerglobalscope]: https://html.spec.whatwg.org/multipage/workers.html#workerglobalscope
[response]: https://fetch.spec.whatwg.org/#concept-response
[request]: https://fetch.spec.whatwg.org/#concept-request
[HTTPS state]: https://fetch.spec.whatwg.org/#concept-response-https-state
[origin]: https://url.spec.whatwg.org/#concept-url-origin
[url]: https://fetch.spec.whatwg.org/#concept-response-url
[potentially trustworthy]: https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy
[header list]: https://fetch.spec.whatwg.org/#concept-response-header-list
[header]: https://fetch.spec.whatwg.org/#concept-header
[name]: https://fetch.spec.whatwg.org/#concept-header-name
[value]: https://fetch.spec.whatwg.org/#concept-header-value
[xhr-open]: https://xhr.spec.whatwg.org/#the-open()-method
[docwrite method]: https://html.spec.whatwg.org/#dom-document-write
[async]: https://html.spec.whatwg.org/#attr-script-async
[defer]: https://html.spec.whatwg.org/#attr-script-defer
[prepare a script]: https://html.spec.whatwg.org/#prepare-a-script
[non-blocking]: https://html.spec.whatwg.org/#non-blocking
[header-append]: https://fetch.spec.whatwg.org/#concept-header-list-append
[header-list]: https://fetch.spec.whatwg.org/#concept-request-header-list
[fetching algorithm]: https://fetch.spec.whatwg.org/#fetching
[global object]: https://html.spec.whatwg.org/multipage/webappapis.html#global-object
[current global object]: https://html.spec.whatwg.org/#current-global-object
[client]: https://fetch.spec.whatwg.org/#concept-request-client
[sender requirements]: https://greenbytes.de/tech/webdav/draft-ietf-httpbis-jfv-02.html#rfc.section.3
[non-blocking]: https://html.spec.whatwg.org/#non-blocking
[URL parser]: https://url.spec.whatwg.org/#concept-url-parser
[origin-of-url]: https://url.spec.whatwg.org/#concept-url-origin
[ascii case-insensitive]: https://html.spec.whatwg.org/multipage/infrastructure.html#ascii-case-insensitive
[document]: https://html.spec.whatwg.org/multipage/dom.html#document
[meta]: https://html.spec.whatwg.org/#the-meta-element
[http-equiv]: https://html.spec.whatwg.org/#attr-meta-http-equiv
[meta-content]: https://html.spec.whatwg.org/#attr-meta-content
[pragma directives]: https://html.spec.whatwg.org/#attr-meta-http-equiv-content-security-policy
[extended attribute]: https://heycam.github.io/webidl/#dfn-extended-attribute
[take an identifier]: https://heycam.github.io/webidl/#dfn-xattr-identifier
[global name]: https://heycam.github.io/webidl/#dfn-global-name
[exposed]: https://heycam.github.io/webidl/#dfn-exposed
[cookie attribute]: https://html.spec.whatwg.org/#dom-document-cookie
[domain attribute]: https://html.spec.whatwg.org/#dom-document-domain
[top-level browsing context]: https://html.spec.whatwg.org/#top-level-browsing-context
[nested browsing context]: https://html.spec.whatwg.org/#nested-browsing-context
[document.write]: https://html.spec.whatwg.org/#dom-document-write
[document.writeln]: https://html.spec.whatwg.org/#dom-document-writeln
[Geolocation interface]: https://www.w3.org/TR/geolocation-API/#geolocation_interface
[NavigatorUserMedia interface]: https://w3c.github.io/mediacapture-main/#navigatorusermedia
[RTCPeerConnection interface]: http://w3c.github.io/webrtc-pc/#rtcpeerconnection-interface
[Notification interface]: https://www.w3.org/TR/notifications/#notification
[PaymentRequest interface]: https://www.w3.org/TR/payment-request/#paymentrequest-interface
[PushManager interface]: https://w3c.github.io/push-api/#idl-def-PushManager
[requestMIDIAccess method]: http://webaudio.github.io/web-midi-api/#requestMIDIAccess
[vibrate method]: https://w3c.github.io/vibration/#idl-def-navigator-vibrate(vibratepattern)
